#### 正则表达式

#### 使用简单的模式
`/abc/`

在` "Hi, do you know your abc's?" `会匹配成功

在`"Grab crab"`中将不会被匹配


#### 使用特殊字符
`/ab*c/`

匹配一个单独的 `a` 后面跟了零个或者多个 `b`,且后面跟着`c` 的任何字符组合。

在字符串 `cbbabbbbcdebc` 中，这个模式匹配了子字符串`abbbbc`。


#### 匹配电话号码格式 
电话号码格式：000-12345，该格式前面有 3 位数字，然后紧跟着连字符-，连字符后面再跟着 5 位数字。
`/^\d{3}-\d{5}$/.test(telephoneNumber)`


# 匹配位置

## 匹配位置

**例子：`I Love U`**

### ^
匹配开头的位置，当正则有修饰符 m 时(多行文本)，表示匹配行开头位置。

例如，`/^A/` 并不会匹配` "an A"` 中的 `'A'`，但是会匹配 `"An E"`的 `'A'`。

> 当 '^' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。

### $
匹配结尾的位置，当正则有修饰符 m 时(多行文本)，表示匹配行结尾位置。

例如，`/t$/ `并不会匹配` "eater"` 中的` 't'`，但是会匹配` "eat"` 中的` 't'`。


### \b
**匹配单词边界，即匹配上面示例中的 i、love、U 前后的位置**

一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）

例子：

`/\bm/`匹配`“moon”`中得`‘m’`；

`/oo\b/`并不匹配`"moon"`中得`'oo'`，因为'oo'被一个“字”字符'n'紧跟着。

`/oon\b/`匹配`"moon"`中得`'oon'`，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。

`/\w\b\w/`将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。


> `[\b]`	匹配一个退格(U+0008)。（不要和\b混淆了。）

### \B
**匹配非单词边界，与 \b 相反，即匹配上面示例中的 o、v、e 前后的位置**

他匹配一个前后字符都是相同类型的位置：都是“字”字符或者都不是“字”字符。一个字符串的开始和结尾都被认为不是“字”字符，或者空字符串。

例如，`/\B../`匹配`"noonday"`中的`'oo'`, 而`/y\B../`匹配`"possibly yesterday"`中的`'yes'`


### (?=表达式)
正向先行断言：(?=表达式)，指在某个位置的右侧必须能匹配表达式。

例如：给定字符串：**我爱你 · 我爱他 · 我爱 · 爱你 · 我和你**

匹配右边是“你”的位置。正则可以这么写: `/(?=你)/g`：**我爱`|`你 · 我爱他 · 我爱 · 爱`|`你 · 我和`|`你**

如果非要加上“爱”，`/爱(?=你)/g`，就会匹配出：**我`爱`你 · 我爱他 · 我爱 · `爱`你 · 我和你**


### (?!表达式)
例如：给定字符串：**我爱你 · 我爱他 · 我爱 · 爱你 · 我和你**

反向先行断言：(?!表达式)，指在某个位置的右侧不能匹配表达式。

与 (?=表达式)正好相反。同样是上面的例子:`/爱(?!你)/g`，就会匹配出：**我爱你 · 我`爱`他 · 我`爱` · 爱你 · 我和你**


### (?<=表达式)
正向后行断言：(?<=表达式)，指在某个位置的左侧必须能匹配表达式。

注意: 先行断言和后行断言只有一个区别，即先行断言从左往右看，后行断言从右往左看。


### (?<!表达式)
反向后行断言：(?<!表达式)，指在某个位置的左侧不能匹配表达式。


### 练习
**test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。**

1.   
匹配以 javascript 开头的字符串    
匹配以 javascript 结尾的字符串

```js
/^javascript/.test('javascript is my favorite'); // true
/javascript$/.test('this code in javascript'); // true
```

2.   
仅匹配有边界的code单词

```js
/\bcode\b/.test('bar code'); // true

/\bcode\b/.test('barcode') // false
```

3.   
匹配姓“李”的名字。

```js
/^李.+/.test('李逍遥');  // true

/^李.+/.test('慕容李逍遥');  // false

// "李" 左侧可以为空格不能为非空格字符
/(?<=[\s]?)(?<!\S)李.+/.test('李逍遥');  // true
```



# 匹配字符

## 字符

### 字母、数字
匹配字符本身。比如`/javascript/`，匹配 "javascript"；`/123/`，匹配 "123"。

### \0
匹配 NUL 字符。

### \t
匹配水平制表符。

### \v
匹配垂直制表符。

### \n	
匹配一个换行符 (U+000A)。

### \r
匹配一个回车符 (U+000D)。

### \f	
匹配一个换页符 (U+000C)。

### \xnn
匹配拉丁字符。比如 \xOA 等价于 \n。

### \uxxxx
匹配 Unicode 字符。比如 \u2028 匹配行终止符，\u2029 匹配段终止符。

### \cX
匹配 ctrl+X。比如 \cI 匹配 ctrl+I，等价于 \t。

### [\b] *(不懂)*
匹配 Backspace 键(特殊记忆)。


## 字符组

### [abc]
匹配 "a"、"b"、"c" 其中任何一个字符。

### [a-d1-4]
匹配 "a"、"b"、"c"、"d"、"1"、"2"、"3"、"4" 其中任何一个字符。

### [^abc]
匹配除了 "a"、"b"、"c" 之外的任何一个字符。

### [^a-d1-4]
匹配除了 "a"、"b"、"c"、"d"、"1"、"2"、"3"、"4" 之外的任何一个字符。

### .
（小数点）通配符，匹配除了少数字符(\n)之外的任意字符。

例如，`/.n/`将会匹配 `"nay, an apple is on the tree" `中的 `'an' `和 `'on'`，但是不会匹配 `'nay'`。

### \d
匹配数字，等价于 [0-9]。

例如，` /\d/` 或者` /[0-9]/ `匹配`"B2 is the suite number."`中的`'2'`。

### \D
匹配非数字，等价于 [^0-9]。

例如， `/\D/` 或者 `[^0-9]/` 匹配`"B2 is the suite number."`中的`'B'` 。

### \w
匹配单词字符，等价于 [a-zA-Z0-9_]。

例如, `/\w/ `匹配 `"apple,"` 中的`'a'`，`"$5.28,"`中的 `'5' `和 `"3D."` 中的`'3'`。

### \W
匹配非单词字符，等价于 [^a-zA-Z0-9_]。

例如, `/\W/` 或者`/[^A-Za-z0-9_]/ `匹配` "50%."` 中的`'%'`。

### \s
匹配空白符，等价于 [ \t\v\n\r\f]。

### \S
匹配非空白符，等价于 [^ \t\v\n\r\f]。

### 练习

1.   
使用字符组匹配 Javascript 和 javascript

```js
const regex = /[Jj]avascript/

regex.test('Javascript');  // true
regex.test('javascript');  // true
```

2.   
匹配“我爱你”或“我想你”或“我”+数字+“你”

```js
const regex = /我[\d爱想]你/

regex.test('我爱你');  // true
regex.test('我想你');  // true
regex.test('我打你');  // false
regex.test('520, 我2你');  // true
```

3.   
匹配爱后面不包含你的数据

```js
/我爱[^你]/.test('我爱你'); // false
```

4.   
匹配数据所有的数字、小写字母和大写字母。

```js
/[a-z0-9A-Z]/.test('b'); // true

/[a-zA-Z\d]/.test('999'); // true

/[a-zA-Z\d]/.test('A'); // true

/[a-zA-Z\d]/.test('A4'); // true
```


## 量词
**{n,m}简单来说就是需要重复的次数**

### {n,m}
连续出现 n 到 m 次。贪婪模式。

### {n,}
至少连续出现 n 次。贪婪模式。

### {n}
连续出现 n 次。贪婪模式。

### ?
匹配前面一个表达式0次或者1次。等价于 {0,1}。贪婪模式。

例如，`/e?le?/` 匹配` "angel"` 中的 `'el'`，和 `"angle"` 中的 `'le' `以及`"oslo'` 中的`'l'`。

如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。

例如，对` "123abc" `应用 `/\d+/ `将会返回 `"123"`，如果使用` /\d+?/`,那么就只会匹配到 `"1"`。

还有对`""<H1>Chapter 1 - 介绍正则表达式</H1>""`,使用`/<.*>/`会匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容`<H1>Chapter 1 - 介绍正则表达式</H1>`;

非贪婪:使用`/<.*?>/`匹配`"<H1>"`.

如果只想匹配开始的 H1 标签，表达式则是：`/<\w+?>/`

还可以运用于先行断言，如本表的 x(?=y) 和 x(?!y) 条目中所述。

### +
匹配前面一个表达式1次或者多次。等价于 {1,}。贪婪模式。

例如，`/a+/`匹配了在` "candy" `中的 `'a'`，和在` "caaaaaaandy" `中所有的` 'a'`。


### *
匹配前一个表达式0次或多次。等价于 {0,}。贪婪模式。

例如，`/bo*/`会匹配 `"A ghost boooooed"` 中的 `'booooo' `和` "A bird warbled" `中的 `'b'`，    
但是在 `"A goat grunted" `中将不会匹配任何东西。


### {n,m}?	
连续出现 n 到 m 次。惰性模式。最多匹配到 n 个

### {n,}?
至少连续出现 n 次。惰性模式。最多匹配到 n 个

### {n}?
连续出现 n 次。惰性模式。

### ??
等价于 {0,1}?。惰性模式。

### +? 
等价于 {1,}?。惰性模式。

### *?
等价于 {0,}?。惰性模式。

+ **贪婪模式――在匹配成功的前提下，尽可能多的去匹配**
+ **惰性模式――在匹配成功的前提下，尽可能少的去匹配**

### 练习

1.   
匹配手机号码，假设手机号码规则如下：
+ 必须是 11 位的数字；
+ 第一位数字必须以 1 开头，第二位数字可以是 [3,4,5,7,8] 中的任意一个，后面 9 个数是 [0-9] 中的任意一个数字。

```js
const regex = new RegExp(/^1[34578]\d{9}/);

regex.test('18711001111') // true
regex.test('13712345678') // true
regex.test('12345678911') // false
```

## 括号的作用
**括号主要是用来分组作用。**

### (ab)	
捕获型分组。把 "ab" 当成一个整体，比如 (ab)+ 表示 "ab" 至少连续出现一次。

### (?:ab)
非捕获型分组。与 (ab) 的区别是，它不捕获数据。

### (good|nice)
捕获型分支结构。匹配 "good" 或 "nice"。

### (?:good|nice)
非捕获型分支结构。与 (good|nice) 的区别是，它不捕获数据。

### \num
反向引用。比如 \2，表示引用的是第二个括号里的捕获的数据。

### 练习

1.   
视频文件的后缀名有 .mp4、.avi、.wmv、.rmvb 用正则表达式提取所有的视频文件的后缀
```js
const regex = new RegExp(/.+(\.mp4|\.avi|\.wmv|\.rmvb)/);

regex.exec('海贼王.avi')
// ['海贼王.avi', '.avi', index: 0, input: '海贼王.avi', groups: undefined]
regex.test('朋友.mp3')
// null
regex.test('学习资料.rmvb')
// ['学习资料.rmvb', '.rmvb', index: 0, input: '学习资料.rmvb', groups: undefined]
```



